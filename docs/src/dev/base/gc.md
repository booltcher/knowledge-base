---
outline: [2, 3]
tags: 
  - JavaScript
publishDate: 2020/05/26
---
# 垃圾回收

> GC - Garbage Collector 垃圾回收器
> 

它是现代编程语言（如 Java、JavaScript、Python 等）中用于自动管理内存的机制，负责回收不再使用的对象以释放内存空间，助开发者避免手动管理内存的复杂性，内存的高效使用和程序的稳定运行。

## 常见的垃圾回收算法

1. **标记-清除（Mark and Sweep）**：
    - 标记所有从根对象（如全局变量、活动函数调用栈）可达的对象。
    - 清除未被标记的对象。
2. **引用计数（Reference Counting）**：
    - 统计每个对象被引用的次数。
    - 当引用计数为 0 时，回收对象。
    - 缺点：无法处理循环引用。
3. **分代回收（Generational Collection）**：
    - 将内存分为新生代和老生代。
    - 新生代存放短期对象，老生代存放长期对象。
    - 对不同代采用不同的回收策略。
4. **增量回收（Incremental Collection）**：
    - 将垃圾回收过程分成多个小步骤执行，减少对程序运行的阻塞。

## 分代回收

基于一个核心：**大多数对象的生命周期都很短**，而少数对象会存活较长时间。

分代回收利用这一现象，将内存划分为不同的“代”（Generations），并对不同代采用不同的回收策略，从而提高垃圾回收的效率。

通常，内存会被划分为两代：

1. **新生代（Young Generation）**：
    - 存放新创建的对象。
    - 新生代的对象生命周期较短，回收频率较高。
    - 新生代的内存空间通常较小。
2. **老生代（Old Generation）**：
    - 存放存活时间较长的对象。
    - 老生代的对象生命周期较长，回收频率较低。
    - 老生代的内存空间通常较大。

在某些实现中，还可能包含一个 **永久代（Permanent Generation）** 或 **元空间（Metaspace）**，用于存放类元数据、常量池等。

### **新生代的回收（Minor GC）**

新生代的回收称为 **Minor GC**，其特点是：

- **频率高**：因为大多数对象在新生代中很快就不再被使用。
- **速度快**：新生代的内存空间较小，回收速度快。

### **新生代的回收算法**

常用的新生代回收算法是 **Scavenge 算法**（一种复制算法）：

**它的核心思想是通过 *复制存活对象* 来实现垃圾回收，同时保证了内存的紧凑性。**

**如何判断存活对象是通过 可达性分析，从根对象出发，递归遍历可达对象，不可达对象会被丢弃清理。**

1. **内存划分**：
    - 新生代内存被划分为两个区域：**From 空间** 和 **To 空间**。
2. **对象分配**：
    - 新创建的对象首先分配到 From 空间。
3. **垃圾回收**：
    - 当 From 空间满时，触发 Minor GC。
    - 将 From 空间中存活的对象复制到 To 空间。
    - 清空 From 空间。
4. **空间交换**：
    - 交换 From 和 To 空间的角色，继续分配新对象。

### **对象晋升（Promotion）**

- 如果对象在多次 Minor GC 后仍然存活，则将其晋升到老生代。
- 晋升条件可以是对象存活的次数（年龄）或对象的大小。

### **老生代的回收（Major GC / Full GC）**

老生代的回收称为 **Major GC** 或 **Full GC**，其特点是：

- **频率低**：因为老生代的对象生命周期较长。
- **速度慢**：老生代的内存空间较大，回收速度较慢。

### **老生代的回收算法**

常用的老生代回收算法是 **标记-清除（Mark-Sweep）** 或 **标记-整理（Mark-Compact）**：


1. **标记阶段**：
    - 从根对象（如全局变量、活动函数调用栈）出发，标记所有可达的对象。
2. **清除阶段**：
    - 清除未被标记的对象（即不可达的对象）。
3. **整理阶段（可选）**：
    - 在标记-整理算法中，会将存活的对象移动到内存的一端，以**减少内存碎片**。
    