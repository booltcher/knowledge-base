---
outline: [2, 3]
tags: 
  - AWS
publishDate: 2022/03/26
---

# Integration & Messaging

## 概览

- 当我们部署了多个应用时，他们必然需要和其他应用交流
- 交流往往有两种方式：
    - 同步：应用 => 应用
    - 异步：应用 => 队列 => 应用
- 同步存在一些问题，比如购买量激增导致其中一个应用击垮其他的应用
- 所以为了突然的流量高峰或者一些无法预测的情况，需要将应用直接解耦：
    - SQS：队列模型
    - SNS：发布/订阅模型
    - Kinesis：实时流模型
- 这些服务可以独立于SQS,SNS,Kinesis来拓展

## SQS

> Simple/Standard Queue Seivice
> 

### 什么是队列

- 生产者：任何向SQS队列发送消息(Send message)的端为 生产者(Producer)，生产者可以有多个
- 消息：可以是任何内容，比如订单，视频，消息会进入队列
- 消费者：需要处理队列中的消息并接受(Poll message)它们的端为 消费者，消费者可以有多个，他们可以在处理完消息后删除
- 队列：像是个缓冲区，使生产者和消费者脱钩

### SQS初识

- AWS的第一批服务，10多年的历史了
- 完全托管的服务，用于**解耦应用程序**
- 特性：
    - 无限的吞吐量（标准）
    - 短暂：默认情况下，消息在队列中停留四天，最长14天。这意味着一旦向消息队列发送消息，必须由消费者在保留期间内处理并删除，否则消息会丢失
    - 低延迟：发送到接受不到10ms
    - 消息体很小：每条消息不得超过256KB
- 可能有重复的消息（标准）
- 可能有乱序的消息（标准：最大努力排序）

### 生产

- 使用SDK(SendMessage API)发送消息到SQS
- 消息将被持久化到SQS队列中，直到有消费者处理并删除
- 保留：4 - 14 天
- 消息的例子 ：需要处理一个订单
    - 订单ID
    - 客户ID
    - 地址等需要的信息

### 消费

- 消费者是应用程序（EC2上运行的、虚拟服务器、Lambda等）
- 轮询：一次最多可以收到10条消息
- 处理：比如将数据插入到RDS数据库，这是开发者写的代码
- 删除：使用DeleteMessage API

### 多个消费者

- 如果一条消息处理得不够快，可能被其他消费者接收，可以并行接受和处理这些消息
- 所以至少是一次交付
- 尽可能为消息排序
- 消费者处理完后应该删除消息
- 可以通过增加消费者来提升SQS的吞吐量（与Auto Scaling Group配合是最佳用例，这是一个常见的集成）

### 安全

- 加密：
    - 使用HTTPS实现飞行中加密
    - KMS实现静态加密
    - 客户端加密解密
- 访问控制：IAM策略
- SQS访问策略：类似于S3bucket策略
    - 跨账户访问
    - 跨服务访问

### 消息可见性超时

- 当一个消费者轮询了一条消息，它对其他消费者会变成不可见的
- 默认的，消息可见超时时间是30秒
- 这意味者消息必须在30s内被处理，因为其他消费者请求消息时那条消息不会被返回
- 可见超时后，如果消息没有被删除，会重新回到消息队列
- 所以如果在可见超时时间内没被处理完成，就可能被多次处理
- 因此，如果消费者已经处理了，只不过需要更多时间，那么可以使用ChangeMessageBisibilite的API来获取更多时间
- 这个时间应该比较合适，不能过长或过短

### 长轮询

- 一个消费者从队列里请求数据时，如果没有消息，可选择等一段时间直到出现消息，这就是长轮询
- 可以降低延迟，并减少API调用次数
- 等待时间可以设置为1 - 20s（显然20s更好）
- 显然长轮询比短轮询更好
- 长轮询可以从队列开启，也可以从API层面开启，使用WaitTimeSeconds

### FIFO 队列

- FIFO = 先进先出(在队列中进行排序)
- 吞吐量有限：不使用批处理每秒300条消息，使用批处理每秒3000条消息
- 仅处理一次（移除重复的）
- 消息将被消费者顺序处理
- 队列名称必须以 .fifo结尾