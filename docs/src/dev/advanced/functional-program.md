---
outline: [2, 3]
tags: 
	- 概念
publishDate: 2022/04/05
---

# 函数式编程
https://www.ruanyifeng.com/blog/2012/04/functional_programming.html

[https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch2.html#%E4%B8%BA%E4%BD%95%E9%92%9F%E7%88%B1%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch2.html#为何钟爱一等公民)

### 定义

函数式编程是一种编程范式，就是如何编写程序的方法论。

它属于结构化编程的一种，主要思想是通过函数的嵌套调用来实现运算过程

即通过管道把数据在一系列纯函数间传递的方式

### 纯函数

相同的输入永远得到相同的输出，且无任何可以观察的副作用。

比如 `slice` 和 `splice`，这两个函数的作用并无二致——但是注意，它们各自的方式却大不同，但不管怎么说作用还是一样的。我们说 `slice` 符合*纯*函数的定义是因为对相同的输入它保证能返回相同的输出。而 `splice` 却会嚼烂调用它的那个数组，然后再吐出来；这就会产生可观察到的副作用，即这个数组永久地改变了。

-- 其实在八年级的时候我们就学到了以数学的角度理解函数的概念：一个输入只有一个输出，而多个输入产生的输出可能相同。所以函数其实本就该是输入和输出的映射关系。纯函数就是数学角度的函数，而同时也是函数式编程的全部。

### 特点

##### 1.函数是一等公民

一等公民：与其他数据类型一样，处于平等地位，可以赋值给其他变量，可以作为参数传递，也可以作为其他函数的返回值

##### 2.声明式代码

只用表达式，不用语句

表达式是一个单纯的运算过程，总有返回值；语句执行某种操作，没有返回值。也就是说函数式编程邀请我们每一步都是单纯的计算，而且有返回值。

它更注重的是做什么，而不是是怎么做

##### 3.没有副作用

副作用：函数内部与外部互动，最典型的例子就是在函数内部去修改全局变量，这会产生运算以外的其他结果。简而言之，就是一切除计算结果之外发生的事情。

- 更改文件系统
- 数据库插入数据

- 发送一个 http 请求
- 可变数据

- 打印/log
- 获取用户输入

- DOM 查询
- 访问系统状态

- ...

函数式编程意味函数要保持独立，所有功能就是去返回一个新的值，没有其他行为。

#### 4.不修改状态

不再通过变量保存状态，而是通过参数保存状态，比如递归的方式。而又因为递归，所以运行速度慢，这是不被推广的重要原因。

##### 5.引用透明

不依赖于外部变量或状态，只依赖于参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。

依赖状态是影响任何程序复杂度的罪魁祸首。

### 意义

1. 代码简洁，开发快速。是因为减少了代码重复
2. 接近自然语言，易于理解，可读性高

3. 更方便的代码管理：不依赖也不修改外部变量，所以每一个函数看作一个独立的个体，有利于 unit test/debug/和模块化重组
4. 易于并发编程：因为不修改变量，不存在锁线程的问题。

5. 代码的热升级：只要保证接口不变，内部实现是与外部无关的。所以可以在运行状态下直接升级，不需要重启也不需要停机。

### Currying

函数只处理参数的一部分，并且会返回一个新的函数去处理剩下的参数。

##### Compose - 组合若干个函数得到一个新的函数。

##### Either - 错误处理

##### Option - 可选的值

##### IO - 副作用

##### Task - 异步

### 工具：

ramda，loadash

## Fp-ts

#### 1.Eq

可以定义一个函数，函数的功能是来判断是否相等，需要传入一个“相等“的定义

例 1:实现一个判断数字是否相等的方法

```typescript
const eqNumber: Eq<number> = {
  equals: (x, y) => x === y,
};
```

例 2:实现一个判断元素是否是数组内元素的方法，原理就是判断数组中是否有至少一项满足定义的“相等”条件

```typescript
const elem<A>(E: Eq<A>):(a:A, as: Array<A>) => boolean{
	return (a, as) => as.some(item => E.equals(items, a))
}
elem(eqNumber)(1, [1, 2, 3]) //true
```

例 3:实现一个判断自定义类型是否相等的方法

比如说两个 person 血型相同且同姓就“相等”

```typescript
type Person {
	lastName: string,
	bloodType: 'A' | 'B' | 'O' | 'AB'
}
const equalPerson:Eq<Person> = {
	equals: (x, y) => x.lastName === y.lastName && x.bloodType === y.bloodType
}
equalPerson({lastName:'a', bloodType:'O'}, {lastName:'a', bloodType:'O'})   //true
```
