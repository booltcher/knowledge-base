---
outline: [2, 3]
tags: Vue
publishDate: 2023/01/12
---

# 组件通信

## 总览

组件通信是组件化的精髓，大抵可分为三种场景 9 种方式：

| 组件关系      | 传递方式                                                                                                           |
| ------------- | :----------------------------------------------------------------------------------------------------------------- |
| 父传子(5)     | [`props`](#✨-props) [自定义事件](#✨-自定义事件) [实例法](#✨-实例法) [`v-model`](#✨-`v-model`) [插槽](#✨-插槽) |
| 祖孙之间(2)   | [透传](#✨-透传)[注入](#✨-注入)                                                                                   |
| 任意组件间(2) | [集中状态管理](#✨-集中状态管理) [事件总线](#✨-事件总线)                                                          |

## ✨ `props`

> 适用于：父子组件

- 在选项式 API 中，子组件通过定义`props`属性来接收父组件传递来的数据。
- 在组合式 API 中，子组件使用`defineProps`方法来定义。

## ✨ 自定义事件

## ✨ 实例法

> 适用于：父子组件

通过获取组件实例的方式来获取数据或调用方法。

- `$parent` 不推荐使用
- `$children` Vue3 中已被废弃
- `$refs`

::: warning 🌋
**为什么不推荐使用？有什么缺点？**

1. **紧耦合性（Tight Coupling）**：使用 **`$parent`** 会使组件和其父组件之间产生紧密耦合。这意味着子组件依赖于其特定父组件的结构和实现细节。这种紧耦合会增加组件间的依赖性，降低了组件的可重用性和可维护性。
2. **可读性差**：在大型应用中，使用 **`$parent`** 可能会使代码变得难以理解和维护。其他开发人员阅读代码时，可能难以确定 **`$parent`** 引用的确切父级组件是哪一个。
3. **不利于单元测试**：依赖 **`$parent`** 会使单元测试变得困难。如果组件依赖于其父级组件，那么在测试组件时需要模拟或者创建这些父级组件的实例，这会增加测试的复杂度。
4. **不稳定性**：当父组件结构发生变化时，比如父组件的层级结构调整或者某些父组件被删除，使用 **`$parent`** 的子组件可能会受到影响，导致代码不稳定。
5. **难以追踪状态变化**
   :::

## ✨ `v-model`

> 适用于：父子组件

在 Vue2 中：
子组件接受 value 属性和 input 方法
Vue3 的实现是`modelValue`和`update:modelValue`方法，这是默认的，可以通过`v-model:xxx`来修改掉默认的`modelValue`，这样的好处是可以设置多个`v-model`。

## ✨ 插槽

> 适用于：父子组件

插槽语法中，子组件可以获取父组件的数据，而要想从子组件传递数据给父组件，可以使用作用域插槽：

```vue
// 父
<current-user>
  <template v-slot:default="slotProps"></template>
</current-user>

// 子
<span>
  <slot v-bind:user="user">
    {{ user.lastName }}
  </slot>
</span>
```

## ✨ 透传

> 适用于：祖先/后代

使用`$attrs`
未被消费过(未通过`props`，`emits`声明过)的属性都会向下级继续传递。

在 JS 中可以通过`useAttrs` 方法来访问透传的属性。

## ✨ 注入

> 适用于：祖先/后代

即`provide`和`inject`。

跨代传递数据，只要是后代都可以拿到。如果是静态数据，可以将`provide`定义为对象，如果是动态数据，可以定义为一个方法返回一个对象。

`inject`可以是一个数组或者对象(`key`为本地的绑定名，`value`为注入的属性名)。

在 vue2 中使用`provide`和`inject`选项，在 Vue3 中他们是来自`vue`的方法：

```js
import { ref, provide } from "vue";

const count = ref(0);
provide("key", count);
```

在插件中常用**应用级别**的注入：

```js
app.provide(/* 注入名 */ "message", /* 值 */ "hello!");
```

## ✨ 集中状态管理

> 适用于：任意组件

- Vuex
- Pinia

## ✨ 发布订阅模型

> 适用于：任意组件

发布订阅模式在 Vue2 中的实现就是事件总线`EventBus`。在 Vue3 中官方没有实现，可以借助第三方库[mitt](https://github.com/developit/mitt)

核心原理很简单，主要实现三个方法：

- `$on` 订阅
- `$emit` 触发、通知
- `$off` 解除

[手写发布订阅模式](/src/dev/javascript/implement/implement-pubsub)

::: warning 🌋
**注意事项：**

1. 组件卸载时，要使用`off`解绑，否则会出现触发多次，且可能引发内存泄露
2. 未加载的组件监听不到
:::
