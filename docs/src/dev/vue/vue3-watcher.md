---
outline: [2, 3]
tags: 
  - Vue
  - Vue3
publishDate: 2024/01/10
---

# 侦听器

## 面试题：`watch` `computed` 和 `methods` 的差别？
**`computed`**

- 语义上：根据多个值计算得出一个值
- 有缓存：会基于响应式依赖进行缓存。只在相关响应式依赖改变时才重新求值。
- 不支持异步

**`watch`**

- 语义上：监听一个值，在它改变时执行某些操作
- 无缓存：只要监听的值发出变化就会执行
- 支持异步
- 支持参数：`deep`和`immediate` 深度监听可用于对象内部属性的监听，数组对象不需要深度监听。

**`methods`**
只要调用就会执行。

## `watch`
可以监听的类型：
- `ref`或`reactive`定义的数据
- `ref`，`reactive`定义的对象上的某个属性
- `getter`
- 以上几种情况构成的数组

### 监视`ref`定义的基本类型数据

不用加`value`。

`watch`的返回值是一个`stop watch`的方法。可以用来解除监视。

### 监视`ref`定义的对象类型数据

默认是监视对象内存地址是否改变，不过可以通过配置`deep: true` 来实现深度监听。`watch`方法接受第三个参数是一个配置对象。

注意：
若修改的是 `ref` 定义的对象中的属性，`newValue` 和 `oldValue` 都是新值，因为它们是同一个对象。
若修改整个 `ref` 定义的对象，`newValue` 是新值，`oldValue` 是旧值，因为不是同一个对象了。

### 监视`reactive`定义的数据(对象)

隐式开启了深层监听，这种深度监听不能被关闭

### 监听`ref`或`reactive`定义的对象类型上的某个属性

如果属性的值是一个基本类型，要写成一个`getter`：

```js
watch(() => person.name, ...)
```

如果属性的值是一个引用类型，可以直接写，但是建议还是写成一个函数，为什么？

如果直接监听对象上的属性，而属性是一个引用类型的值，那只能监听到下层的变化，值被整体修改不会触发`watch`。

**结论：**

**只要监听的是对象上的属性，都推荐使用`getter`**

**如果同时要监听其下层的属性，可以配合`deep`使用**

## `watchEffect`

- 不用指明要监听的属性，直接定义一个回调函数，会**自动追踪依赖**。
- 初始化会执行一次，相当于`watch`设置了`immediate: true`
- 无法获取到变化前的值，只能获取变化后的值

## 侦听器触发时机

如果一个响应式的值更新，会触发组件的更新和watch的回调，但是默认情况是watch的回调先执行，如果要在组件更新后执行：

```jsx
watchEffect(callback, {
  flush: 'post'
})
// 或使用
watchPostEffect(() => {})
```

## 停止

在`setup`里同步语句定义的watcher会绑定在宿主组件实例上，因此当宿主组件卸载时这些watcher会自动停止。

如果是在异步语句中定义的watcher，它不会被绑定在宿主组件实例上，则需要手动停止，否则会发生内存泄露。

如何手动停止？`watch`方法的返回值是一个方法，用来停止watcher。

```js
const unwatch = watchEffect(() => {})

unwatch()
```

**推荐：尽量使用同步语句定义watcher。**